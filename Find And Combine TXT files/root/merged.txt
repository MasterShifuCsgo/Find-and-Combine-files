'Find And Combine TXT files.cpp'

#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <conio.h>  // for _getch(); ... press any key funciton
#include <unordered_set>

#include "Traverser.h" 

// PURPOSE
//Combine all the found txt files found going down from the partent directory.


int main()
{
  
  Traverser tr;

  if (tr.combine()) {
    std::cout << "Complete";
  }




  
  _getch();

  return 0;
}




'Traverser.cpp'
#pragma once

#include <filesystem>
#include <string>
#include <vector>
#include <set>
#include <unordered_set>
#include <iostream>
#include <fstream>
#include "Traverser.h"


namespace fs = std::filesystem;

//logs data to the terminal
#ifdef DEBUG
void msgTerminal(std::string type, std::string msg) {
  std::cout << type << ": " << msg << "\n";
}
#else
inline void msgTerminal(std::string, std::string) {}
#endif

  Traverser::Traverser() {
    //create the root path
    fs::create_directory(Program_Output);

    startingPath = fs::current_path();
    OutputPath = startingPath / Program_Output / OutputFileName;
    //merge.txt | append mode
    output.open(OutputPath, std::ios::app);
    //directorys found
    seenDirectories.push_back(fs::current_path());
  }

  bool Traverser::combine() {

    //continues when there are no other directories to be seen
    while (!seenDirectories.empty()) {
      
      //change directory
      fs::path currentFolder = seenDirectories.back();
      seenDirectories.pop_back();
      msgTerminal("LOG:", "Directory Changed: " + currentFolder.string().substr(startingPath.string().size()));
      fs::path startingDir = (startingPath / Program_Output);

      //start looking for files in the directory
      for (const auto& Entity : fs::directory_iterator(currentFolder)) {

        const auto path = Entity.path();
        const auto filename = Entity.path().filename().string();

        // check if the file is the folder stared
        if (Entity.path() == startingDir) {
          continue; // skip that folder
        }

        //cut out symlink files
        if (fs::is_regular_file(path)) {

          //if current file has accepted extension, append the contents to the merged.txt file
          if (acceptedExtensions.contains(path.extension().string())) {

            //open the found .txt file
            std::ifstream target(path);

            //append the text from the file into the main text file                    
            
            msgTerminal("LOG: ", "File found: " + filename);

            output << '\'' << filename << '\'' << '\n';
            std::string line;
            while (std::getline(target, line)) {
              output << line << '\n';
            }
            output << "\n\n\n";
            target.close();
          }
        }

        //see if the entity is a directory and if directory is not root directory
        if (fs::is_directory(Entity.path()) && Entity.path() != Program_Output) {
          seenDirectories.push_back(Entity.path());
        }
      }
    }
    output.flush();

    return true;
  }




'Traverser.h'
#pragma once
#include <filesystem>
#include <string>
#include <vector>
#include <set>
#include <unordered_set>
#include <iostream>
#include <fstream>

namespace fs = std::filesystem;

constexpr const char* Program_Output("root"); //folder
constexpr const char* extension(".txt");
constexpr const char* fileName("merged");

class Traverser {

  const std::string OutputFileName = std::string(fileName) + extension;

  fs::path OutputPath;
  fs::path startingPath;
  std::ofstream output;
  std::vector<fs::path> seenDirectories;
  
  std::unordered_set<std::string> acceptedExtensions2{
    ".txt",
    ".md"
  };

  std::unordered_set<std::string> acceptedExtensions{
    ".txt",   // Plain text file
    ".md",    // Markdown file
    ".pdf",   // Portable Document Format
    ".doc",   // Microsoft Word document
    ".docx",  // Microsoft Word document (XML-based)
    ".rtf",   // Rich Text Format
    ".odt",   // OpenDocument Text Document
    ".html",  // HTML file
    ".htm",   // HTML file (alternative extension)
    ".csv",   // Comma-separated values
    ".xml",   // XML file
    ".json",  // JSON file
    ".yaml",  // YAML file
    ".yml",   // YAML file (alternative extension)
    ".epub",  // EPUB eBook file
    ".mobi",  // MOBI eBook file
    ".tex",   // LaTeX source file
    ".rst",   // reStructuredText file
    ".log",   // Log file
    ".asc",   // ASCII-armored file (usually GPG, PGP, or plain text)

    // Programming files
    ".cpp",   // C++ source code file
    ".h",     // C/C++ header file
    ".hpp",   // C++ header file (alternative extension)
    ".c",     // C source code file
    ".cs",    // C# source code file
    ".java",  // Java source code file
    ".js",    // JavaScript file
    ".py",    // Python source code file
    ".go",    // Go source code file
    ".php",   // PHP source code file
    ".rb",    // Ruby source code file
    ".swift", // Swift source code file
    ".rs",    // Rust source code file
    ".ts",    // TypeScript file
    ".scala", // Scala source code file
    ".pl"     // Perl script
  };


public:
  Traverser();
  bool combine();

};





'Find And Combine TXT files.log'
﻿  Traverser.cpp
  Generating code
  29 of 777 functions ( 3.7%) were compiled, the rest were copied from previous compilation.
    8 functions were new in current compilation
    112 functions had inline decision re-evaluated but remain unchanged
  Finished generating code
  Find And Combine TXT files.vcxproj -> C:\Users\kaspar\source\repos\Find And Combine TXT files\x64\Release\Find And Combine TXT files.exe



'Find And Combine TXT files.log'
﻿  Find And Combine TXT files.cpp
  Traverser.cpp
  Generating Code...
  Find And Combine TXT files.vcxproj -> C:\Users\kaspar\source\repos\Find And Combine TXT files\x64\Debug\Find And Combine TXT files.exe



